Yiyun Zhang(Benny)
yz523
CS380
HW2
============================================
Part 1 is written problems. The answer is attached in the pdf file - HW2.pdf.
For part A, the reason why backward search is easier has been explained. 
For part B, each question has been answered.
For part C, the modified code is attached, instead of returning the first solution path, continue the loop and add the path to the solution list.
For part D, I generated a tree by hand and recorded the answer in that part. 
============================================
Part 2 is Programming Assignment - Applied two search strategies for Sliding Brick Puzzle
At first, I modified my previous version of the code base on the feedback. 
The first thing is fixed applyMoveCloning, it had bug during the test in hw1.
The second thing is delete unnecessary outputs, which is indicated in the feedback.
The third thing is extract some elements such as movements, pieces and position from the previous messy single class file, 
put them in to separate class files, and create basic methods for them and move corresponding functions to them locally.
Therefore instead of having a 2d matrix everytime, the added board model to the state class is easier to access the elements(rows, columns) and methods realted to it.
I think it will be helpful for hw2.
The last thing is let HW2 class be the real main class, instead of having any methods. 
The time to fix these is longer than I expected, and the implementation of bfs and dfs are also takes time. That's the reason I submit this hw late.
I put the bfs and dfs functions are in the beginning of the puzzle class, right after the basic methods.
For each strategy, there are two parts, the use part and the search part. 
For use part in bfs, it has a loop that start visiting from root node. And in the loop it calls the search part to do the search of all leaves under that node.
The explored node has been counted in the search part, and the used time calcluated in the use part.
For use part in bfs, it has a loop that start visiting from root node. And in the loop it calls the search part to do the search of all nodes until the null, repeat state or success.
The explored node has also been counted in the search part, and the used time calcluated in the use part.
============================================
To use this program, type make in the console window.
The makefile will execute and build class files.
Then type java HW2 SBP-level2.txt bfs(or dfs), the output will printed in the console window.
The sample output is:
yz523@tux3:~/cs380/hw2$ java HW2 SBP-level2.txt bfs
(3,left)
(2,left)
(4,left)
(5,up)
(7,up)
(7,right)
(8,up)
(8,right)
(5,down)
(5,left)
(7,left)
(5,down)
(2,down)
(4,left)
(5,up)
(2,right)
(3,right)
(6,up)
(6,up)
(7,left)
(7,up)
(8,left)
(8,left)
(2,down)
(5,down)
(7,right)
(4,right)
(3,right)
(6,up)
(8,up)
(2,left)
(2,left)
(2,left)
6,5,
1,1,1,1,1,1,
1,0,3,2,2,1,
1,0,3,4,5,1,
-1,6,6,7,8,1,
1,1,1,1,1,1,
Explored node:723
Time took:176.0ms
Solution size:33

yz523@tux3:~/cs380/hw2$ java HW2 SBP-level2.txt dfs
(3,left)
(2,left)
(4,left)
(2,right)
(4,up)
(5,left)
(4,down)
(2,left)
(8,up)
(2,right)
(4,up)
(5,left)
(6,left)
(8,right)
(6,right)
(5,right)
(4,down)
(2,left)
(6,up)
(6,right)
(5,right)
(5,down)
(2,down)
(4,left)
(4,left)
(5,up)
(2,right)
(4,right)
(2,left)
(8,up)
(4,left)
(5,left)
(6,up)
(2,right)
(4,down)
(4,left)
(5,left)
(8,right)
(5,right)
(4,right)
(6,up)
(2,left)
(6,down)
(5,right)
(4,right)
(7,right)
(3,down)
(3,left)
(3,left)
(2,up)
(6,left)
(4,down)
(2,right)
(3,right)
(3,down)
(2,left)
(2,left)
(5,up)
(3,right)
(2,right)
(4,up)
(5,right)
(3,down)
(2,left)
(3,left)
(6,up)
(6,right)
(7,up)
(8,left)
(7,down)
(4,down)
(3,right)
(2,right)
(4,up)
(7,left)
(3,down)
(2,left)
(3,left)
(6,up)
(6,right)
(7,up)
(8,left)
(6,down)
(6,left)
(4,down)
(3,right)
(2,right)
(4,up)
(6,down)
(3,down)
(2,left)
(3,left)
(5,right)
(3,right)
(2,right)
(4,up)
(6,left)
(5,left)
(4,down)
(2,right)
(7,left)
(2,left)
(5,up)
(5,right)
(7,up)
(7,right)
(3,down)
(2,left)
(3,left)
(8,left)
(3,right)
(2,right)
(4,up)
(7,left)
(5,down)
(5,left)
(4,down)
(2,right)
(5,down)
(2,left)
(4,right)
(2,right)
(3,right)
(5,up)
(4,up)
(6,left)
(3,down)
(3,down)
(2,left)
(2,left)
(5,up)
(7,up)
(6,right)
(5,right)
(4,right)
(4,down)
(2,down)
(3,left)
(3,left)
(4,up)
(5,up)
(4,down)
(3,right)
(8,up)
(3,left)
(4,left)
(6,up)
(6,right)
(2,right)
(7,up)
(8,right)
(6,down)
(2,left)
(4,down)
(3,right)
(7,right)
(3,left)
(4,left)
(6,up)
(7,left)
(5,down)
(8,left)
(4,right)
(3,right)
(5,down)
(2,right)
(3,left)
(2,left)
(4,left)
(2,right)
(5,up)
(2,left)
(4,down)
(3,right)
(8,right)
(3,left)
(5,up)
(2,right)
(6,up)
(7,right)
(6,down)
(2,left)
(4,down)
(3,right)
(6,right)
(3,left)
(5,up)
(7,up)
(7,right)
(2,down)
(2,left)
6,5,
1,1,1,1,1,1,
1,0,3,2,2,1,
1,0,3,4,5,1,
-1,6,6,7,8,1,
1,1,1,1,1,1,
Explored node:237
Time took:77.0ms
Solution size:191